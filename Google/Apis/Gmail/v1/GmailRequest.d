/*
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
/*
 * This code was generated by https://github.com/google/apis-client-generator/
 * Modify at your own risk.
 */
module Google.Apis.Gmail.v1.GmailRequest;

import requests;
import url;
import std.typecons: Nullable;
import std.conv: to;
import vibe.data.json;
import std.json;

/**
 * Gmail request.
 */
public class GmailRequest(
  RequestT = Request,
  ResponseT = Response,
  string HttpMethod = "GET",
  RequestType = Object,
  ResponseType = Object,
  MediaContentType = string) {
  private static const ulong KB = 0x10000;

  private static const DEFAULT_CHUNK_SIZE = 256 * KB;
  
  RequestT request;
  URL url;
  string restPath;
  RequestType content;
  MediaContentType mediaContent;

  public this(string restPath, string urlString) {
    this.restPath = restPath;

    url = (urlString ~ restPath).parseURL;
  }

  private ulong chunkSize = DEFAULT_CHUNK_SIZE;
  public auto setChunkSize(ulong chunkSize) {
    this.chunkSize = chunkSize;
    return this;
  }

  public ulong getChunkSize() {
    return this.chunkSize;
  }

  /** V1 error format. */
  private string xgafv;

  /**
   * V1 error format.
   */
  public string getXgafv() {
    return xgafv;
  }

  /** V1 error format. */
  public auto setXgafv(string xgafv) {
    this.xgafv = xgafv;
    set!(string)("xgafv", xgafv);
    return this;
  }
  /** OAuth access token. */
  private string accessToken;

  /**
   * OAuth access token.
   */
  public string getAccessToken() {
    return accessToken;
  }

  /** OAuth access token. */
  public auto setAccessToken(string accessToken) {
    this.accessToken = accessToken;
    set!(string)("accessToken", accessToken);
    return this;
  }
  /** Data format for response. */
  private string alt;

  /**
   * Data format for response. [default: json]
   */
  public string getAlt() {
    return alt;
  }

  /** Data format for response. */
  public auto setAlt(string alt) {
    this.alt = alt;
    set!(string)("alt", alt);
    return this;
  }
  /** JSONP */
  private string callback;

  /**
   * JSONP
   */
  public string getCallback() {
    return callback;
  }

  /** JSONP */
  public auto setCallback(string callback) {
    this.callback = callback;
    set!(string)("callback", callback);
    return this;
  }
  /** Selector specifying which fields to include in a partial response. */
  private string fields;

  /**
   * Selector specifying which fields to include in a partial response.
   */
  public string getFields() {
    return fields;
  }

  /** Selector specifying which fields to include in a partial response. */
  public auto setFields(string fields) {
    this.fields = fields;
    set!(string)("fields", fields);
    return this;
  }
  /**
   * API key. Your API key identifies your project and provides you with API access, quota, and
   * reports. Required unless you provide an OAuth 2.0 token.
   */
  private string key;

  /**
   * API key. Your API key identifies your project and provides you with API access, quota, and
   * reports. Required unless you provide an OAuth 2.0 token.
   */
  public string getKey() {
    return key;
  }

  /**
   * API key. Your API key identifies your project and provides you with API access, quota, and
   * reports. Required unless you provide an OAuth 2.0 token.
   */
  public auto setKey(string key) {
    this.key = key;
    set!(string)("key", key);
    return this;
  }
  /** OAuth 2.0 token for the current user. */
  private string oauthToken;

  /**
   * OAuth 2.0 token for the current user.
   */
  public string getOauthToken() {
    return oauthToken;
  }

  /** OAuth 2.0 token for the current user. */
  public auto setOauthToken(string oauthToken) {
    this.oauthToken = oauthToken;
    set!(string)("oauthToken", oauthToken);
    return this;
  }
  /** Returns response with indentations and line breaks. */
  private Nullable!bool prettyPrint;

  /**
   * Returns response with indentations and line breaks. [default: true]
   */
  public Nullable!bool getPrettyPrint() {
    return prettyPrint;
  }

  /** Returns response with indentations and line breaks. */
  public auto setPrettyPrint(Nullable!bool prettyPrint) {
    this.prettyPrint = prettyPrint;
    set!(Nullable!bool)("prettyPrint", prettyPrint);
    return this;
  }
  /**
   * Available to use for quota purposes for server-side applications. Can be any arbitrary string
   * assigned to a user, but should not exceed 40 characters.
   */
  private string quotaUser;

  /**
   * Available to use for quota purposes for server-side applications. Can be any arbitrary string
   * assigned to a user, but should not exceed 40 characters.
   */
  public string getQuotaUser() {
    return quotaUser;
  }

  /**
   * Available to use for quota purposes for server-side applications. Can be any arbitrary string
   * assigned to a user, but should not exceed 40 characters.
   */
  public auto setQuotaUser(string quotaUser) {
    this.quotaUser = quotaUser;
    set!(string)("quotaUser", quotaUser);
    return this;
  }
  /** Legacy upload protocol for media (e.g. "media", "multipart"). */
  private string uploadType;

  /**
   * Legacy upload protocol for media (e.g. "media", "multipart").
   */
  public string getUploadType() {
    return uploadType;
  }

  /** Legacy upload protocol for media (e.g. "media", "multipart"). */
  public auto setUploadType(string uploadType) {
    this.uploadType = uploadType;
    set!(string)("uploadType", uploadType);
    return this;
  }
  /** Upload protocol for media (e.g. "raw", "multipart"). */
  private string uploadProtocol;

  /**
   * Upload protocol for media (e.g. "raw", "multipart").
   */
  public string getUploadProtocol() {
    return uploadProtocol;
  }

  /** Upload protocol for media (e.g. "raw", "multipart"). */
  public auto setUploadProtocol(string uploadProtocol) {
    this.uploadProtocol = uploadProtocol;
    set!(string)("uploadProtocol", uploadProtocol);
    return this;
  }

  public void set(T)(string parameterName, auto ref T value) {
    url.queryParams.add(parameterName, to!string(value));
  }

  private Json getInitializedFields(Json json) {
    Json ret = Json.emptyObject;

    foreach (jkey, jvalue; json.byKeyValue) {
      Json temp = jvalue.type == Json.Type.object ? getInitializedFields(jvalue) : Json("");
      if (temp == Json.emptyObject) continue;
      if (temp != Json("") && jvalue.type == Json.Type.object) {
        ret[jkey[1..$]] = temp;
      } else if (jvalue.type != Json.Type.null_ && jvalue != Json("") && jvalue != Json.emptyArray) {
        ret[jkey[1..$]] = jvalue;
      }
    }

    return ret;
  }

  private Json serializeModelToJson(T) (
    auto ref T value
  ) {
    return getInitializedFields(value.serializeToJson());    
  }

  private T deserializeJsonToModel(T) (
    ref Json json
  ) {
    string str = json.toString;

    import std.regex;
    auto re = regex("[a-zA-Z./]+\":");
    str = replaceAll(str, re, "_$&");

    json = str.serializeToJson();

    return json.deserializeJson!T();
  }

  import std.stdio: File;
  private ResponseType doResumableUpload(string InitialHttpMethod)() {
    set("uploadType", "resumable");

    request.addHeaders([
      "Authorization": "Bearer " ~ oauthToken,
      "Content-Type": "application/json"
    ]);

    string metadata = content is RequestType.init ? "" : serializeModelToJson(content).toString;

    auto response = request.exec!HttpMethod(url, metadata);
    string location = response.responseHeaders["location"];

    ResponseType responseContent;

    static if (is(MediaContentType == string)) {
      request.addHeaders([
        "Content-Range": "bytes 0-" ~ to!string(mediaContent.length - 1) ~ "/" ~ to!string(mediaContent.length)
      ]);

      response = request.exec!"PUT"(location, mediaContent);
    } else static if (is(MediaContentType == File)) {
      ulong totalRead = 0;
      ulong fileSize = mediaContent.size;

      foreach (ubyte[] buffer; mediaContent.byChunk(chunkSize)) {
        request.clearHeaders();
        totalRead += buffer.length;
        request.addHeaders([
          "Content-Range": "bytes " ~ to!(string)(totalRead - buffer.length) ~  "-" ~ to!(string)(totalRead - 1) ~ "/" ~ to!(string)(fileSize),
          "Content-Length": to!(string)(buffer.length)
        ]);

        response = request.exec!"PUT"(location, buffer);

      }
    }
    string resString = response.responseBody.toString;

    import std.regex;
    auto re = regex("[a-zA-Z./]+\":");
    resString = replaceAll(resString, re, "_$&");    

    Json resJson = parseJSON(resString).serializeToJson();
    responseContent = resJson.deserializeJson!ResponseType();

    return responseContent;
  }

  public ResponseType upload() {
    return doResumableUpload!HttpMethod();
  }

  public ResponseType execute() {
    string metadata = is(RequestType == Object) ? "" : serializeModelToJson(content).toString;
    
    request.addHeaders([
      "Authorization": "Bearer " ~ oauthToken,
      "Content-Type": "application/json"
    ]);

    ResponseT res = request.exec!HttpMethod(url, metadata);

    static if (!is(ResponseType == Object)) {
      ResponseType response; 
      string resString = res.responseBody.toString;

      import std.regex;
      auto re = regex("[a-zA-Z./]+\":");
      resString = replaceAll(resString, re, "_$&");    

      Json resJson = parseJSON(resString).serializeToJson();
      response = resJson.deserializeJson!ResponseType();

      return response;
    } else {
      return ResponseType();
    }
  }
}
